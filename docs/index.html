<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>International Fantasy</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --bg-url: url("./international_2025_ls_3_4k.jpg"); }
    body{
      min-height:100vh;
      color:#e6e8eb;
      background:
        linear-gradient(180deg, rgba(14,16,20,.74), rgba(14,16,20,.74)),
        var(--bg-url) center/cover fixed no-repeat;
    }
    .card{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 16px;
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
    }
    .chip{ background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18); }
    .chip-btn{ cursor:pointer; user-select:none; transition:all .2s ease; }
    .chip-btn.active{ background:#6366f1; border-color:#818cf8; color:white; }

    *{ scrollbar-width: thin; scrollbar-color: rgba(148,163,184,.6) transparent; }
    ::-webkit-scrollbar{ width:10px; height:10px; }
    ::-webkit-scrollbar-track{
      background: linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
      border-radius: 9999px;
    }
    ::-webkit-scrollbar-thumb{
      background: linear-gradient(180deg,rgba(148,163,184,.85),rgba(203,213,225,.85));
      border-radius: 9999px; border: 2px solid rgba(17,24,39,.45);
    }
    ::-webkit-scrollbar-thumb:hover{
      background: linear-gradient(180deg,rgba(180,193,210,.95),rgba(226,232,240,.95));
    }

    .rank-badge{ font-variant-numeric: tabular-nums; }
    .medal-1{ background: linear-gradient(135deg,#ffd700,#ffb100); color:#111; }
    .medal-2{ background: linear-gradient(135deg,#c0c0c0,#a8a8a8); color:#111; }
    .medal-3{ background: linear-gradient(135deg,#cd7f32,#b36a25); color:#111; }

    .podium{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.9rem; }
    .podium > .podium-card{ transform-origin:center bottom; }
    .podium > .first{ order:2; transform: translateY(-6px) scale(1.03); }
    .podium > .second{ order:1; }
    .podium > .third{ order:3; }
    .podium .card{ min-height:140px; }
    @media (min-width:768px){ .podium .card{ min-height:165px; } }

    .flip-animate{ transition: transform .5s cubic-bezier(.2,.7,.2,1), opacity .3s ease; will-change: transform; }
    .trend-up{ color:#34d399; } .trend-down{ color:#f87171; } .trend-flat{ color:#9ca3af; }
    .details{ display:none; } .row-open .details{ display:block; }

    .flip-card{ cursor:pointer; }
    .flip-inner{ position:relative; width:100%; height:100%; }
    .flip-face{
      position:absolute; inset:0; display:flex; flex-direction:column;
      align-items:center; justify-content:center; gap:.6rem; padding:1rem;
      transition: transform .45s cubic-bezier(.2,.7,.2,1), opacity .3s ease;
      transform: rotateY(0); opacity:1;
      backface-visibility: hidden;
    }
    .flip-face.back{ overflow-y:auto; max-height:260px; 
      transform: rotateY(180deg);
      opacity:0;
      justify-content:center; align-items:center;
      overflow:hidden; padding:1rem;
    }
    .flipped .flip-face.front{ transform: rotateY(180deg); opacity:0; pointer-events:none; }
    .flipped .flip-face.back{ overflow-y:auto; max-height:260px;   transform: rotateY(0);    opacity:1; pointer-events:auto; }

    .mini-columns{
      width:100%; max-width:560px;
      display:grid; grid-template-columns: 1fr 1fr; gap:22px;
      align-items:start;
    }

    .flip-face.back::-webkit-scrollbar{ width:8px; }
    .flip-face.back::-webkit-scrollbar-thumb{ background: rgba(148,163,184,.7); border-radius: 6px; }

    .mini-grid{ display:grid; grid-template-columns: 1fr auto; column-gap:18px; row-gap:.35rem; font-size:.95rem; }

    .popover{ position:relative; }
    .popover-menu{
      position:absolute; top:110%; right:0;
      background: rgba(17,24,39,.94);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 12px;
      box-shadow: 0 18px 50px rgba(0,0,0,.5);
      padding: .35rem; min-width: 180px;
      backdrop-filter: blur(8px);
      display: none; z-index: 50;
    }
    .popover.open .popover-menu{ display:block; }
    .menu-item{ padding: .5rem .65rem; border-radius: 8px; cursor: pointer; white-space: nowrap; }
    .menu-item:hover{ background: rgba(99,102,241,.25); }

    .roster-grid{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.35rem .75rem; }
    .roster-grid div{ font-size:.9rem; }
  </style>

  <script>
    // Phase groupings
    window.phaseConfig = {
      ti2024: { "Group Stage":[1,2,3,4], "Event Playoffs":[5,6,7], "Main Event":[8,9,10] },
      ti2025: { "Today":[], "Group Stage & Special Eliminator":[1,2,3,4], "Playoffs":[5,6,7,8] }
    };
    window.defaultLockHourLocal = null; // optional default lock hour
  </script>
</head>
<body>
  <header class="max-w-6xl mx-auto px-4 pt-10 pb-6 flex items-center justify-between">
    <div>
      <h1 class="text-3xl md:text-4xl font-extrabold tracking-tight drop-shadow">INTERNATIONAL FANTASY</h1>
    </div>
    <div id="authBox" class="flex gap-3 items-center"></div>
  </header>

  <main class="max-w-6xl mx-auto px-4 pb-24">
    <div class="flex flex-wrap gap-3 items-center mb-6">
      <span id="pill-2025" class="px-3 py-1 rounded-full chip chip-btn text-sm">TI 2025</span>
      <span id="pill-2024" class="px-3 py-1 rounded-full chip chip-btn text-sm">TI 2024</span>
      <a href="submit.html" class="ml-auto px-4 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600 text-white font-semibold shadow">Submit Lineup</a>
    </div>

    <section class="card rounded-2xl p-4 md:p-6">
      <div id="lbStatus" class="text-sm text-gray-300 mb-4"></div>

      <!-- Control row: Today first, then phase chips, then day dropdown -->
      <div class="flex flex-wrap items-center gap-2 mb-4">
        <span id="todayChip" class="px-3 py-1 rounded-full chip chip-btn text-sm">Today</span>
        <div id="phaseTabsInner" class="flex flex-wrap gap-2"></div>

        <div id="daySortBox" class="popover ml-auto">
          <button id="daySortBtn" type="button" aria-expanded="false"
                  class="px-3 py-1 rounded-full chip chip-btn text-sm inline-flex items-center gap-1">
            <span id="daySortLabel">Sort by Day</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M6 9l6 6 6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div id="daySortMenu" class="popover-menu"></div>
        </div>
      </div>

      <div id="podium" class="podium mb-6"></div>

      <div class="max-h-[520px] overflow-auto rounded-xl border border-white/15">
        <ul id="lbList" class="divide-y divide-white/10"></ul>
      </div>
    </section>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
    import { getFirestore, collection, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";
    import { setupAuthUI } from "./assets/auth-ui.js";

    // Firebase
    const app = initializeApp({
      apiKey:"AIzaSyAx8jWSAZdR_rzgVP8XumxNOvsy86bjl-Q",
      authDomain:"internationalfantasy2025.firebaseapp.com",
      projectId:"internationalfantasy2025",
      storageBucket:"internationalfantasy2025.firebasestorage.app",
      messagingSenderId:"864977028555",
      appId:"1:864977028555:web:8038b630cba08cc661624e"
    });
    const { db } = setupAuthUI({ app, headerEl: document.getElementById('authBox'), cardClass: 'card' });

    // Elements
    const pill2025 = document.getElementById('pill-2025');
    const pill2024 = document.getElementById('pill-2024');
    const phaseTabsInner = document.getElementById('phaseTabsInner');
    const todayChip = document.getElementById('todayChip');
    const lbStatus = document.getElementById('lbStatus');
    const podiumEl = document.getElementById('podium');
    const listEl   = document.getElementById('lbList');
    const daySortBox = document.getElementById('daySortBox');
    const daySortBtn = document.getElementById('daySortBtn');
    const daySortLabel = document.getElementById('daySortLabel');
    const daySortMenu = document.getElementById('daySortMenu');

    // State
    let currentTid = 'ti2025';
    let currentPhase = null;
    let prevRanks = new Map();
    let cache = { ti2024: null, ti2025: null };
    let sortByDayIndex = null;
    let todayMode = false;
    let unsub = null;

    // Baseline storage
    function baseKey(dayIdx){
      return [currentTid, (currentPhase||'__overall'), (dayIdx!=null?('day'+dayIdx):'total')].join('|');
    }
    function loadBaseline(dayIdx){
      try{
        const raw = localStorage.getItem('if_baseline_'+baseKey(dayIdx));
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || !obj.ranks) return null;
        return new Map(Object.entries(obj.ranks).map(([k,v])=>[k, Number(v)]));
      }catch{ return null; }
    }
    function saveBaseline(dayIdx, ranksMap){
      const payload = { when: new Date().toISOString(), ranks: Object.fromEntries(ranksMap) };
      try{ localStorage.setItem('if_baseline_'+baseKey(dayIdx), JSON.stringify(payload)); }catch{}
    }
    function ensureBaseline(dayIdx, ranksMap){
      if (!loadBaseline(dayIdx)) saveBaseline(dayIdx, ranksMap);
    }
    function docLockTime(data){
      const cands = [data?.lockAt, data?.lockedAt, data?.lock, data?.meta?.lockAt, data?.meta?.lockedAt].filter(Boolean);
      for (const c of cands){
        const t = Date.parse(c);
        if (!Number.isNaN(t)) return t;
      }
      return null;
    }

    // Directory caches
    // playersDir: Map(steam32 -> playerName)
    const playersDir = new Map();
    // lineupsByDayKey: { [dateKey]: { byMid: Map(mid->entry), byManager: Map(lowerName->entry) } }
    const lineupsByDayKey = {};

    // Load players directory
    async function loadPlayers(){
      playersDir.clear();
      try{
        const snaps = await getDocs(collection(db,'players'));
        snaps.forEach(d=>{
          const p = d.data() || {};
          const id = p.steam32 ?? p.id32 ?? p.sid32 ?? p.steamId32 ?? p.id;
          const name = p.name ?? p.player_name ?? p.player ?? p.tag ?? p.nickname;
          if (id!=null && name) playersDir.set(String(id), String(name));
        });
      }catch(e){
        // ignore if players collection doesn't exist
      }
    }

    // Load lineups with schema per screenshot
    async function loadLineups(tid){
      for (const k of Object.keys(lineupsByDayKey)) delete lineupsByDayKey[k];
      try{
        const snaps = await getDocs(collection(db,'lineups'));
        snaps.forEach(d=>{
          const data = d.data() || {};
          if (data.tid && data.tid !== tid) return;
          const dateKey = data.dateKey || (typeof d.id==='string' && (d.id.match(/(\d{8})/)||[])[1]) || null;
          if (!dateKey) return;
          if (!lineupsByDayKey[dateKey]) lineupsByDayKey[dateKey] = { byMid:new Map(), byManager:new Map() };

          const mid = (data.mid || data.ownerUid || '').toString();
          const mname = (data.managerName || data.manager || '').toString().trim().toLowerCase();
          const entry = {
            dateKey,
            mid,
            managerLower: mname,
            captain: data.captain,      // steam32 (string/number)
            cores: Array.isArray(data.cores)? data.cores : [],
            supports: Array.isArray(data.supports)? data.supports : [],
            teamCard: data.teamCard || data.team || null
          };
          if (mid) lineupsByDayKey[dateKey].byMid.set(mid, entry);
          if (mname) lineupsByDayKey[dateKey].byManager.set(mname, entry);
        });
      }catch(e){
        console.warn('lineups load failed', e);
      }
    }

    // Helpers
    function markYearPillActive(){
      pill2025.classList.toggle('active', currentTid==='ti2025');
      pill2024.classList.toggle('active', currentTid==='ti2024');
    }
    function buildInnerPhaseTabs(){
      phaseTabsInner.innerHTML = '';
      const conf = window.phaseConfig[currentTid] || {};
      const phases = Object.keys(conf).filter(k=>k!=='Today'); // Today is its own chip
      if (currentPhase && !phases.includes(currentPhase)) currentPhase = null;
      phases.forEach(phase=>{
        const el = document.createElement('span');
        el.className = 'px-3 py-1 rounded-full chip chip-btn text-sm ' + (phase===currentPhase?'active':'');
        el.textContent = phase;
        el.onclick = ()=>{
          currentPhase = (currentPhase === phase) ? null : phase;
          renderFromCache();
        };
        phaseTabsInner.appendChild(el);
      });
    }
    function buildDaySortMenu(dayCount){
      daySortMenu.innerHTML='';
      const any=document.createElement('div');
      any.className='menu-item text-sm text-gray-200';
      any.textContent='Total (all days)';
      any.onclick=()=>{ sortByDayIndex=null; todayMode=false; daySortLabel.textContent='Sort by Day'; todayChip.classList.remove('active'); renderFromCache(); daySortBox.classList.remove('open'); daySortBtn.setAttribute('aria-expanded','false'); };
      daySortMenu.appendChild(any);
      for(let i=1;i<=dayCount;i++){
        const item=document.createElement('div');
        item.className='menu-item text-sm text-gray-200';
        item.textContent=`Day ${i}`;
        item.onclick=()=>{ sortByDayIndex=i; todayMode=false; daySortLabel.textContent=`Day ${i}`; todayChip.classList.remove('active'); renderFromCache(); daySortBox.classList.remove('open'); daySortBtn.setAttribute('aria-expanded','false'); };
        daySortMenu.appendChild(item);
      }
    }
    daySortBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = daySortBox.classList.toggle('open');
      daySortBtn.setAttribute('aria-expanded', String(open));
    });
    document.addEventListener('click', (e)=>{
      if (!daySortBox.contains(e.target)){
        daySortBox.classList.remove('open');
        daySortBtn.setAttribute('aria-expanded','false');
      }
    });

    const fmt = (n)=>Number(n||0).toFixed(2);
    const trendIcon = (prev, curr) => {
      if (prev==null) return {icon:'→', cls:'trend-flat', delta:0};
      const d = prev - curr;
      if (d>0)  return {icon:'↑', cls:'trend-up', delta:d};
      if (d<0)  return {icon:'↓', cls:'trend-down', delta:Math.abs(d)};
      return {icon:'→', cls:'trend-flat', delta:0};
    };

    /* ---------- Roster rendering ---------- */
    // Convert leaderboard entry roster -> display list with names & points
    function rosterFromLeaderboardEntry(roster){
      if (!Array.isArray(roster)) return null;
      const out = [];
      let coreIdx = 0, supIdx = 0;
      for (const item of roster){
        if (!item || !item.role) continue;
        if (item.role === 'Captain'){
          const nm = nameFromSteam(item.steam32) || String(item.steam32||'');
          out.push({ role: 'Captain', name: nm, points: Number(item.points||0) });
        } else if (item.role === 'Core'){
          coreIdx += 1;
          const nm = nameFromSteam(item.steam32) || String(item.steam32||'');
          out.push({ role: `Core ${coreIdx}`, name: nm, points: Number(item.points||0) });
        } else if (item.role === 'Support'){
          supIdx += 1;
          const nm = nameFromSteam(item.steam32) || String(item.steam32||'');
          out.push({ role: `Support ${supIdx}`, name: nm, points: Number(item.points||0) });
        } else if (item.role === 'Team'){
          const nm = item.name || item.teamId || 'Team';
          out.push({ role: 'Team', name: nm, points: Number(item.points||0) });
        }
      }
      return out.length ? out : null;
    }
    
    function nameFromSteam(steam32){
      if (steam32==null) return null;
      const nm = playersDir.get(String(steam32));
      return nm || null;
    }
    function normalizeRosterFromLineup(lineup){
      if (!lineup) return null;
      const out = [];
      if (lineup.captain!=null){
        out.push({ role:'Captain', name: nameFromSteam(lineup.captain) || String(lineup.captain), points: 0 });
      }
      (lineup.cores||[]).forEach((sid,i)=>{
        out.push({ role:`Core ${i+1}`, name: nameFromSteam(sid) || String(sid), points: 0 });
      });
      (lineup.supports||[]).forEach((sid,i)=>{
        out.push({ role:`Support ${i+1}`, name: nameFromSteam(sid) || String(sid), points: 0 });
      });
      if (lineup.teamCard){
        out.push({ role:'Team', name: lineup.teamCard, points: 0 });
      }
      return out.length ? out : null;
    }
    function rosterHTMLFromList(list){
      if (!list) return '<div class="text-xs text-gray-400">No roster data for this day.</div>';
      return `
        <div class="space-y-1">
          ${list.map(item=>`
            <div class="grid grid-cols-3 items-center text-sm">
              <div class="text-gray-400">${item.role}</div>
              <div class="font-medium truncate">${item.name}</div>
              <div class="text-right font-semibold">${fmt(item.points)}</div>
            </div>
          `).join('')}
        </div>
      `;
    }

    /* ---------- Leaderboard shaping ---------- */
    // Keep per-day manager rows with uid = mid when available
    function rowsFromDayDocs(dayDocs){
      const managerSet = new Set();
      const nameByUid  = new Map();
      const nameByUidLower = new Map();
      const pointsByManagerByDay = new Map();
      const dateKeyByDayIndex = new Map();

      const sorted = [...dayDocs].sort((a,b)=> a.id.localeCompare(b.id));
      sorted.forEach(({id, data}, idx)=>{
        const dayIdx = idx + 1;
        const dayKey = data?.dateKey || (id.match(/(\d{8})/)||[])[1] || null;
        if (dayKey) dateKeyByDayIndex.set(dayIdx, String(dayKey));

        const entries = Array.isArray(data.entries) ? data.entries : [];
        for (const e of entries) {
          const uid = String(e.mid || e.managerName || e.manager || Math.random());
          managerSet.add(uid);
          const managerName = String(e.managerName || e.manager || uid);
          if (!nameByUid.has(uid)){
            nameByUid.set(uid, managerName);
            nameByUidLower.set(uid, managerName.trim().toLowerCase());
          }
          if (!pointsByManagerByDay.has(uid)) pointsByManagerByDay.set(uid, new Map());
          pointsByManagerByDay.get(uid).set(dayIdx, Number(e.totalPoints||0));
        }
      });
      return { managerSet, nameByUid, nameByUidLower, pointsByManagerByDay, dayCount: sorted.length, dateKeyByDayIndex };
    }

    function phaseDaySet(tid){
      const conf = window.phaseConfig[tid] || {};
      if (!currentPhase || currentPhase==='Today') return null;
      const def = conf[currentPhase];
      return new Set(def || []);
    }

    
    function buildRows(dayDocs, tid=currentTid){
      const { managerSet, nameByUid, nameByUidLower, pointsByManagerByDay, dayCount, dateKeyByDayIndex } = rowsFromDayDocs(dayDocs);
      buildDaySortMenu(dayCount);

      const effectiveDayIndex = todayMode ? (dayCount || 1) : sortByDayIndex;
      const includeDays = phaseDaySet(tid);

      const rows = Array.from(managerSet).map(uid=>{
        const byDay = pointsByManagerByDay.get(uid) || new Map();
        let total = 0; const details = [];
        byDay.forEach((points, dayIdx)=>{
          if (!includeDays || includeDays.has(dayIdx)){
            total += points;
            details.push({ label: `Day ${dayIdx}`, points });
          }
        });
        const sortDayValue = effectiveDayIndex ? (byDay.get(effectiveDayIndex) || 0) : null;
        const name = nameByUid.get(uid) || uid;
        const nameLower = nameByUidLower.get(uid) || String(name).toLowerCase();
        return { uid, name, nameLower, total, _details: details, sortDayValue };
      });

      rows.sort((a,b)=> effectiveDayIndex ? (b.sortDayValue - a.sortDayValue) || (b.total - a.total) : (b.total - a.total));

      const dayLabelsByUid = {}; rows.forEach(r=>{ dayLabelsByUid[r.uid] = r._details; });

      const rosterByUid = {};
      if (effectiveDayIndex){
        const dayDoc = dayDocs[effectiveDayIndex-1] || null;
        const entries = dayDoc && Array.isArray(dayDoc.data.entries) ? dayDoc.data.entries : [];
        const map = new Map();
        for (const e of entries){
          const uid = String(e.mid || e.managerName || e.manager || '');
          const disp = rosterFromLeaderboardEntry(e.roster);
          if (uid && disp) map.set(uid, disp);
        }
        rows.forEach(r=>{
          if (map.has(r.uid)){
            rosterByUid[r.uid] = map.get(r.uid);
          } else {
            const dateKey = dateKeyByDayIndex.get(effectiveDayIndex) || null;
            const idx = dateKey ? lineupsByDayKey[dateKey] : null;
            let lineup = null;
            if (idx){
              lineup = idx.byMid.get(r.uid) || idx.byManager.get(r.nameLower) || null;
            }
            rosterByUid[r.uid] = normalizeRosterFromLineup(lineup);
          }
        });
      }

      return { rows, dayLabelsByUid, dayCount, effectiveDayIndex, rosterByUid };
    }


    /* ---------- Fetchers ---------- */
    function docIsForTid(id, data, tid){
      if (data && typeof data.tid === 'string') return data.tid === tid;
      return id.toLowerCase().includes(tid.toLowerCase());
    }

    async function loadYear(tid){
      if (unsub) { try{unsub();}catch{} unsub=null; }
      lbStatus.textContent = `Listening for ${tid.toUpperCase()} — ${currentPhase || 'Overall'}…`;

      // preload players + lineups
      await loadPlayers();
      await loadLineups(tid);

      const coll = collection(db,'leaderboards');
      unsub = onSnapshot(coll, snaps=>{
        const dayDocs=[];
        snaps.forEach(d=>{
          const data = d.data() || {};
          if (docIsForTid(d.id, data, tid)) dayDocs.push({id:d.id, data});
        });
        cache[tid]=dayDocs;
        renderFromCache(true);
      }, (err)=> console.warn('leaderboard watch error', err?.code || err));
    }

    /* ---------- Render ---------- */
    function computeRanksMap(rows){
      const m = new Map();
      rows.forEach((r,i)=> m.set(r.uid, i+1));
      return m;
    }

    function chooseBaseline(dayCount, effectiveDayIndex, bundle, rows){
      let lockMillis = null;
      if (effectiveDayIndex && bundle[effectiveDayIndex-1]){
        lockMillis = docLockTime(bundle[effectiveDayIndex-1].data);
      }
      if (!lockMillis && effectiveDayIndex && window.defaultLockHourLocal!=null){
        const now = new Date();
        const synth = new Date(now.getFullYear(), now.getMonth(), now.getDate(), window.defaultLockHourLocal, 0, 0);
        lockMillis = synth.getTime();
      }
      const ranksNow = computeRanksMap(rows);
      const keyDay = (effectiveDayIndex || null);
      let baseline = loadBaseline(keyDay);
      const nowMs = Date.now();
      const lockSatisfied = !effectiveDayIndex || !lockMillis || nowMs >= lockMillis;
      if (!baseline && lockSatisfied){
        ensureBaseline(keyDay, ranksNow);
        baseline = loadBaseline(keyDay);
      }
      if (!baseline) baseline = ranksNow;
      return baseline;
    }

    function renderPodium(rows, rosterByUid=null, effectiveDayIndex=null, baselineRanks=null){
      podiumEl.innerHTML = '';
      const [first, second, third] = [rows[0], rows[1], rows[2]];
      if (!first) return;

      const cards = [];
      if (second) cards.push({r: second, place:2, pos:'second', medal:'medal-2'});
      cards.push({r: first, place:1, pos:'first',  medal:'medal-1'});
      if (third)  cards.push({r: third,  place:3, pos:'third',  medal:'medal-3'});

      cards.forEach(({r,place,pos,medal})=>{
        const details = Array.isArray(r._details) ? r._details : [];
        const maxShown = 10;
        const normalized = Array.from({length: Math.min(maxShown, details.length)}, (_,i)=> details[i] || {label:`Day ${i+1}`, points:0});
        const left  = normalized.slice(0,5);
        const right = normalized.slice(5,10);
        const colHTML = arr => arr.map(d=>`
          <div class="text-gray-300">${d.label}</div>
          <div class="text-right font-semibold">${fmt(d.points)}</div>
        `).join('');

        const t = trendIcon(baselineRanks?.get(r.uid), place);
        const el = document.createElement('div');
        el.className = `podium-card ${pos} flip-card`;
        el.dataset.uid = r.uid;
        el.dataset.key = r.uid;

        const backInner = effectiveDayIndex
          ? `<div class="w-full max-w-sm mx-auto">
               <div class="text-xs text-gray-400 mb-2 text-center">Day ${effectiveDayIndex} Drafted Team</div>
               ${rosterHTMLFromList(rosterByUid?.[r.uid] || null)}
             </div>`
          : `<div class="mini-columns">
               <div class="mini-grid">${colHTML(left)}</div>
               <div class="mini-grid">${colHTML(right)}</div>
             </div>`;

        el.innerHTML = `
          <div class="flip-inner card rounded-2xl p-4 text-center">
            <div class="flip-face front">
              <div class="inline-flex items-center gap-2 mb-2 justify-center">
                <span class="px-2 py-0.5 rounded rank-badge text-xs ${medal}">#${place}</span>
                <span class="${t.cls} text-sm">${t.icon}${t.delta?` ${t.delta}`:''}</span>
              </div>
              <div class="text-lg font-bold">${r.name}</div>
              <div class="text-2xl font-extrabold mt-1">${fmt(r.total)}</div>
            </div>
            <div class="flip-face back">
              ${backInner}
            </div>
          </div>`;
        podiumEl.appendChild(el);
      });

      podiumEl.querySelectorAll('.flip-card').forEach(el=>{
        el.addEventListener('click', ()=> el.classList.toggle('flipped'));
      });
    }

    function flipAnimate(container, updater){
      const first = new Map();
      Array.from(container.children).forEach(el => first.set(el.dataset.key, el.getBoundingClientRect()));
      updater();
      Array.from(container.children).forEach(el=>{
        const key = el.dataset.key;
        const last = el.getBoundingClientRect();
        const f = first.get(key);
        if (!f) return;
        const dx = f.left - last.left;
        const dy = f.top  - last.top;
        el.style.transform = `translate(${dx}px, ${dy}px)`;
        el.style.opacity = '0.7';
        requestAnimationFrame(()=>{
          el.classList.add('flip-animate');
          el.style.transform = '';
          el.style.opacity = '1';
          el.addEventListener('transitionend', ()=>el.classList.remove('flip-animate'), {once:true});
        });
      });
    }

    function renderList(rows, dayLabelsByUid, rosterByUid=null, effectiveDayIndex=null, baselineRanks=null){
      flipAnimate(listEl, () => {
        listEl.innerHTML = rows.slice(3).map((r,idx)=>{
          const rank = idx + 4;
          const t = trendIcon(baselineRanks?.get(r.uid), rank);

          const detailsRows = effectiveDayIndex
            ? `
              <div class="text-xs text-gray-400 mb-1">Day ${effectiveDayIndex} Drafted Team</div>
              ${rosterHTMLFromList(rosterByUid?.[r.uid] || null)}
            `
            : (dayLabelsByUid[r.uid]||[]).map(x=>`
                <div class="grid grid-cols-2 text-xs py-0.5">
                  <div class="text-gray-300">${x.label}</div>
                  <div class="text-right font-semibold">${fmt(x.points)}</div>
                </div>
              `).join('');

          const rightLabel = effectiveDayIndex ? `Day ${effectiveDayIndex}` : 'Total';
          const rightValue = effectiveDayIndex ? fmt(r.sortDayValue||0) : fmt(r.total);

          return `
            <li class="px-4 py-3 cursor-pointer" data-key="${r.uid}">
              <div class="flex items-center gap-3">
                <span class="w-10 shrink-0 text-right font-semibold tabular-nums">#${rank}</span>
                <span class="${t.cls} w-8 shrink-0">${t.icon}${t.delta?` ${t.delta}`:''}</span>
                <span class="flex-1 font-medium">${r.name}</span>
                <span class="text-sm text-gray-300">${rightLabel}</span>
                <span class="w-24 text-right font-semibold">${rightValue}</span>
              </div>
              <div class="details mt-2 pl-10 pr-2">
                <div class="border-t border-white/10 pt-2">
                  ${detailsRows || '<div class="text-xs text-gray-400">No per-day scores for this phase.</div>'}
                </div>
              </div>
            </li>
          `;
        }).join('');
      });

      listEl.querySelectorAll('li').forEach(li=>{
        li.addEventListener('click', ()=> li.classList.toggle('row-open'));
      });
    }

    function renderFromCache(isSnapshot=false){
      markYearPillActive(); buildInnerPhaseTabs();
      const bundle=currentTid==='ti2024'?cache.ti2024:cache.ti2025;

      if(!bundle || !bundle.length){
        podiumEl.innerHTML = '';
        listEl.innerHTML = '';
        lbStatus.textContent = `0 managers — ${currentTid.toUpperCase()} • ${currentPhase || 'Overall'}`;
        return;
      }

      const { rows, dayLabelsByUid, dayCount, effectiveDayIndex, rosterByUid } = buildRows(bundle, currentTid);

      if (todayMode){
        daySortLabel.textContent = `Day ${dayCount}`;
        todayChip.classList.add('active');
      } else if (!sortByDayIndex){
        daySortLabel.textContent = 'Sort by Day';
        todayChip.classList.remove('active');
      } else {
        daySortLabel.textContent = `Day ${sortByDayIndex}`;
        todayChip.classList.remove('active');
      }

      const baselineRanks = chooseBaseline(dayCount, effectiveDayIndex, bundle, rows);

      renderPodium(rows, rosterByUid, effectiveDayIndex, baselineRanks);
      renderList(rows, dayLabelsByUid, rosterByUid, effectiveDayIndex, baselineRanks);

      const statusSuffix = effectiveDayIndex?` • Sorted by Day ${effectiveDayIndex}`:'';
      lbStatus.textContent = `${rows.length} managers — ${currentTid.toUpperCase()} • ${currentPhase||'Overall'}${statusSuffix}`;

      prevRanks = new Map(); rows.forEach((r,i)=> prevRanks.set(r.uid,i+1));
    }

    /* ---------- Interactions ---------- */
    function switchYear(toTid){
      currentTid=toTid; prevRanks=new Map(); currentPhase=null; sortByDayIndex=null; todayMode=false;
      daySortLabel.textContent='Sort by Day'; daySortBox.classList.remove('open'); daySortBtn.setAttribute('aria-expanded','false');
      buildInnerPhaseTabs(); loadYear(toTid);
    }
    pill2025.addEventListener('click', ()=>{ if(currentTid!=='ti2025') switchYear('ti2025'); });
    pill2024.addEventListener('click', ()=>{ if(currentTid!=='ti2024') switchYear('ti2024'); });

    todayChip.addEventListener('click', ()=>{
      todayMode = !todayMode;
      if (!todayMode){
        sortByDayIndex = null;
        daySortLabel.textContent = 'Sort by Day';
      }
      renderFromCache();
    });

    // Boot
    switchYear('ti2025');
  </script>
</body>
</html>
